## 题目
https://www.acwing.com/problem/content/837/

## python3
```python3
N = 100010
idx = 0
cnt = [0] * N
son = [[0] * 26 for _ in range(N)]

def insert(s):
    global idx
    p = 0
    # 从根节点开始，从前向后遍历字符串
    for i in range(len(s)):
        u = ord(s[i]) - ord('a')
        # 如果当前这个点上不存在对应的字母的话，创建出来
        if (son[p][u] == 0):
            idx += 1
            son[p][u] = idx
        # 进入到当前节点的儿子节点
        p = son[p][u]
    # p对应的点就是最后一个点，cnt[p]++表示以这个点结尾的单词数量加1
    cnt[p] += 1
        
def query(s):
    global idx
    p = 0
    for i in range(len(s)):
        u = ord(s[i]) - ord('a')
        # 如果不存在这个子节点的话，说明集合中不存在这个单词
        if (son[p][u] == 0):
            return 0
        # 进入到当前节点的儿子节点
        p = son[p][u]
    # 返回以p结尾的单词数量
    return cnt[p]

def main():
    global idx
    n = int(input())
    while (n > 0):
        opt, s = list(input().split(" "))
        tmp = list(s)
        if (opt == "I"):
            insert(tmp)
        elif (opt == "Q"):
            print(query(tmp))
        n -= 1

# [
#     [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
#     [0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
#     [0, 4, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
#     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
#     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
#     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
#     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
#     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
#     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
#     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
# ]
# [0, 0, 1, 1, 1, 1, 0, 0, 0, 0]

# [
#   [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
#   [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
#   [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
#   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
#   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
#   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
#   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
#   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
#   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
#   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
# ]
# [0, 1, 1, 1, 0, 0, 0, 0, 0, 0]

# 为什么插两次可以达到cnt计算数量的目的？
# 因为当插入的字母之前已经存在的时候,并不会新增idx,只会通过son[p][u]往下找,当当前字符串遍历完成的时候此时
# 的idx和上一次插入字母的idx是相同的,这样就能达到累加的效果

# 对idx的理解
# 第 i 列只能存对应的字母。而第０行的第 i 列，存的是以26个字母开头的单词。所以每次搜索要从 P = 0开始。
至于 idx 就相当于一个单词前后字母指向后面字母的指针一样

# reference
# https://www.acwing.com/solution/content/5673/  (评论区)
# https://www.acwing.com/solution/content/33114/
# https://www.acwing.com/solution/content/46196/
# https://www.acwing.com/solution/content/60533/
# https://www.acwing.com/solution/content/60533/
# 最后cnt[p] 的含义
# 就是该字符串出现的次数。比如上图的: abc 这条字符串单链表已经到头了，那么我们就 cnt[p]++,
# p代表的就是c字符所对应的idx,idx我已经说了它和一个字符是唯一对应的，这里的唯一对应不仅是字符对应的关系还有位置(即树的层数)。
# 因为第1层的” a ” 和 第二层的 ” a ” 是不同的。



main()
```
